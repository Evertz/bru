import { Long } from 'long';
import { Observable } from 'rxjs';

import { BuildEvent, StreamId } from './build-events';
import { Duration } from './duration';
import { Empty } from './empty';

// Build event with contextual information about the stream it belongs to and
// its position in that stream.
export interface OrderedBuildEvent {
  // Which build event stream this event belongs to.
  streamId: StreamId;

  // The position of this event in the stream. The sequence numbers for a build
  // event stream should be a sequence of consecutive natural numbers starting
  // from one. (1, 2, 3, ...)
  sequenceNumber: Long;

  // The actual event.
  event: BuildEvent;
}

// States which event has been committed. Any failure to commit will cause
// RPC errors, hence not recorded by this proto.
export interface PublishBuildToolEventStreamResponse {
  // The stream that contains this event.
  streamId: StreamId;

  // The sequence number of this event that has been committed.
  sequenceNumber: number;
}

// Streaming request message for PublishBuildToolEventStream.
export interface PublishBuildToolEventStreamRequest {
  // The build event with position info.
  // New publishing clients should use this field rather than the 3 above.
  orderedBuildEvent: OrderedBuildEvent;

  // The keywords to be attached to the notification which notifies the start
  // of a new build event stream. BES only reads this field when sequence_number
  // or ordered_build_event.sequence_number is 1 in this message. If this field
  // is empty, BES will not publish notification messages for this stream.
  notificationKeywords: string[];

  // The project this build is associated with.
  // This should match the project used for the initial call to
  // PublishLifecycleEvent (containing a BuildEnqueued message).
  projectId: string;
}

// The service level of the build request. Backends only uses this value when
// the BuildEnqueued event is published to determine what level of service
// this build should receive.
export enum ServiceLevel {
  // Non-interactive builds can tolerate longer event latencies. This is the
  // default ServiceLevel if callers do not specify one.
  NONINTERACTIVE,

  // The events of an interactive build should be delivered with low latency.
  INTERACTIVE
}

// Publishes 'lifecycle events' that update the high-level state of a build:
// - BuildEnqueued: When a build is scheduled.
// - InvocationAttemptStarted: When work for a build starts; there can be
//     multiple invocations for a build (e.g. retries).
// - InvocationAttemptCompleted: When work for a build finishes.
// - BuildFinished: When a build is finished.
export interface PublishLifecycleEventRequest {
  // The interactivity of this build.
  serviceLevel: ServiceLevel;

  // The lifecycle build event. If this is a build tool event, the RPC will fail
  // with INVALID_REQUEST.
  buildEvent: OrderedBuildEvent;

  // If the next event for this build or invocation (depending on the event
  // type) hasn't been published after this duration from when {build_event}
  // is written to BES, consider this stream expired. If this field is not set,
  // BES backend will use its own default value.
  streamTimeout: Duration;

  // Additional information about a build request. These are define by the event
  // publishers, and the Build Event Service does not validate or interpret
  // them. They are used while notifying internal systems of new builds and
  // invocations if the OrderedBuildEvent.event type is
  // BuildEnqueued/InvocationAttemptStarted.
  notificationKeywords: string[];

  // The project this build is associated with.
  // This should match the project used for the initial call to
  // PublishLifecycleEvent (containing a BuildEnqueued message).
  projectId: string;
}

// A service for publishing BuildEvents. BuildEvents are generated by Build
// Systems to record actions taken during a Build. Events occur in streams,
// are identified by a StreamId, and ordered by sequence number in a stream.
//
// A Build may contain several streams of BuildEvents, depending on the systems
// that are involved in the Build. Some BuildEvents are used to declare the
// beginning and end of major portions of a Build; these are called
// LifecycleEvents, and are used (for example) to indicate the beginning or end
// of a Build, and the beginning or end of an Invocation attempt (there can be
// more than 1 Invocation in a Build if, for example, a failure occurs somewhere
// and it needs to be retried).
//
// Other, build-tool events represent actions taken by the Build tool, such as
// target objects produced via compilation, tests run, et cetera. There could be
// more than one build tool stream for an invocation attempt of a build.
export interface PublishBuildEvent {
  // Publish a build event stating the new state of a build (typically from the
  // build queue). The BuildEnqueued event must be publishd before all other
  // events for the same build ID.
  //
  // The backend will persist the event and deliver it to registered frontend
  // jobs immediately without batching.
  //
  // The commit status of the request is reported by the RPC's util_status()
  // function. The error code is the canoncial error code defined in
  // //util/task/codes.proto.
  publishLifecycleEvent(data: PublishLifecycleEventRequest): Empty;

  // Publish build tool events belonging to the same stream to a backend job
  // using bidirectional streaming.
  publishBuildToolEventStream(data$: Observable<PublishBuildToolEventStreamRequest>): Observable<PublishBuildToolEventStreamResponse>;
}
